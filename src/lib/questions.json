
[
  {
    "chapter": 1,
    "question": "What is the primary purpose of a Zener diode in a circuit?",
    "options": [
      "To amplify the input signal",
      "To regulate voltage",
      "To rectify AC to DC",
      "To store charge"
    ],
    "answer": "b",
    "explanation": "The correct answer is <strong>b) To regulate voltage</strong>. A Zener diode is specifically designed to operate in its reverse breakdown region, allowing it to maintain a constant voltage across its terminals, making it ideal for voltage regulation.",
    "marks": 1
  },
  {
    "chapter": 2,
    "question": "Which logic gate is known as a universal gate?",
    "options": [
      "AND",
      "OR",
      "NAND",
      "XOR"
    ],
    "answer": "c",
    "explanation": "The correct answer is <strong>c) NAND</strong>. A universal gate is a gate from which any other logic gate (like AND, OR, NOT, XOR, etc.) can be created. Both NAND and NOR gates are universal gates. For example, a NOT gate can be made by connecting the inputs of a NAND gate together.",
    "marks": 1
  },
  {
    "chapter": 3,
    "question": "In C programming, what is the difference between `++i` and `i++`?",
    "options": [
      "There is no difference",
      "`++i` is pre-increment, `i++` is post-increment",
      "`++i` is for integers, `i++` is for floats",
      "`++i` is faster than `i++`"
    ],
    "answer": "b",
    "explanation": "The correct answer is <strong>b) `++i` is pre-increment, `i++` is post-increment</strong>. `++i` (pre-increment) increments the value of `i` first and then uses the new value in the expression. `i++` (post-increment) uses the current value of `i` in the expression first and then increments it.",
    "marks": 1
  },
  {
    "chapter": 4,
    "question": "What is the main advantage of using a cache memory?",
    "options": [
      "It has a larger capacity than RAM",
      "It is non-volatile",
      "It reduces the average memory access time",
      "It is cheaper than main memory"
    ],
    "answer": "c",
    "explanation": "The correct answer is <strong>c) It reduces the average memory access time</strong>. Cache is a smaller, faster memory located closer to the CPU that stores copies of the data from the most frequently used main memory locations. It allows the CPU to access data faster than retrieving it from the main memory (RAM).",
    "marks": 1
  },
  {
    "chapter": 5,
    "question": "Which protocol operates at the Transport Layer of the OSI model?",
    "options": [
      "IP",
      "TCP",
      "HTTP",
      "Ethernet"
    ],
    "answer": "b",
    "explanation": "The correct answer is <strong>b) TCP</strong>. The Transport Layer (Layer 4) is responsible for end-to-end communication. TCP (Transmission Control Protocol) and UDP are the two primary protocols at this layer. IP operates at the Network Layer, HTTP at the Application Layer, and Ethernet at the Data Link Layer.",
    "marks": 1
  },
  {
    "chapter": 6,
    "question": "What is a key characteristic of a regular language?",
    "options": [
      "It can be recognized by a Turing machine",
      "It can be recognized by a finite automaton",
      "It requires a stack for recognition",
      "It is context-sensitive"
    ],
    "answer": "b",
    "explanation": "The correct answer is <strong>b) It can be recognized by a finite automaton</strong>. Regular languages are a class of formal languages that can be recognized by a finite automaton (like a DFA or NFA). While a Turing machine can also recognize them, a finite automaton is the least powerful automaton that can do so. Languages requiring a stack are context-free languages.",
    "marks": 1
  },
  {
    "chapter": 7,
    "question": "What is the time complexity of a binary search algorithm?",
    "options": [
      "O(n)",
      "O(log n)",
      "O(n^2)",
      "O(1)"
    ],
    "answer": "b",
    "explanation": "The correct answer is <strong>b) O(log n)</strong>. Binary search is an efficient algorithm for finding an item from a sorted list of items. It works by repeatedly dividing in half the portion of the list that could contain the item, until you've narrowed down the possible locations to just one. This logarithmic time complexity makes it very fast for large datasets.",
    "marks": 1
  },
  {
    "chapter": 8,
    "question": "What is the primary goal of the Agile model of software development?",
    "options": [
      "To have comprehensive documentation",
      "To deliver working software frequently",
      "To have a fixed budget and timeline",
      "To avoid customer feedback until the end"
    ],
    "answer": "b",
    "explanation": "The correct answer is <strong>b) To deliver working software frequently</strong>. The core idea of Agile is to develop and release software in small, iterative cycles. This allows for flexibility, continuous feedback from the customer, and the ability to adapt to changing requirements, rather than focusing on heavy upfront documentation or rigid plans.",
    "marks": 1
  },
  {
    "chapter": 9,
    "question": "In the context of AI, what is a 'heuristic'?",
    "options": [
      "A guaranteed optimal solution",
      "A rule of thumb or shortcut for problem-solving",
      "A type of neural network",
      "A formal logic system"
    ],
    "answer": "b",
    "explanation": "The correct answer is <strong>b) A rule of thumb or shortcut for problem-solving</strong>. Heuristics are practical, experience-based techniques that help in problem-solving, learning, and discovery. They are not guaranteed to be optimal or perfect but are used to speed up the process of finding a satisfactory solution, especially in complex problems where an exhaustive search is impractical.",
    "marks": 1
  },
  {
    "chapter": 10,
    "question": "What does PERT stand for in project management?",
    "options": [
      "Project Evaluation and Resource Tracking",
      "Program Evaluation and Review Technique",
      "Project Execution and Reporting Tool",
      "Program Execution and Review Task"
    ],
    "answer": "b",
    "explanation": "The correct answer is <strong>b) Program Evaluation and Review Technique</strong>. PERT is a statistical tool used in project management to analyze and represent the tasks involved in completing a given project.",
    "marks": 1
  },
  {
    "chapter": 1,
    "question": "A 10V source is connected to two 10Ω resistors in series. What is the total current flowing from the source?",
    "options": [
      "1A",
      "0.5A",
      "2A",
      "0.25A"
    ],
    "answer": "b",
    "explanation": "The correct answer is <strong>b) 0.5A</strong>. In a series circuit, the total resistance is the sum of individual resistances: R_total = 10Ω + 10Ω = 20Ω. Using Ohm's law (I = V/R), the current is I = 10V / 20Ω = 0.5A.",
    "marks": 2
  },
  {
    "chapter": 1,
    "question": "Explain the principle of operation of a full-wave bridge rectifier.",
    "options": [
      "It uses one diode to rectify the AC signal.",
      "It uses two diodes and a center-tapped transformer.",
      "It uses four diodes to rectify both halves of the AC cycle.",
      "It uses a capacitor to smooth the DC output."
    ],
    "answer": "c",
    "explanation": "The correct answer is <strong>c) It uses four diodes to rectify both halves of the AC cycle</strong>. A full-wave bridge rectifier uses four diodes arranged in a bridge configuration. During the positive half-cycle of the AC input, two diodes are forward-biased, and during the negative half-cycle, the other two diodes are forward-biased. This allows the circuit to convert the entire AC waveform into a pulsating DC waveform.",
    "marks": 2
  },
  {
    "chapter": 2,
    "question": "Simplify the Boolean expression A + A'B.",
    "options": [
      "A + B",
      "A' + B",
      "A",
      "B"
    ],
    "answer": "a",
    "explanation": "The correct answer is <strong>a) A + B</strong>. Using the distributive law of Boolean algebra, A + A'B = (A + A')(A + B). Since A + A' = 1, the expression simplifies to 1 * (A + B) = A + B.",
    "marks": 2
  },
  {
    "chapter": 2,
    "question": "Design a 2-to-4 decoder using basic logic gates.",
    "options": [
      "It requires 2 AND gates and 4 NOT gates.",
      "It requires 4 AND gates and 2 NOT gates.",
      "It requires 2 OR gates and 4 AND gates.",
      "It requires 4 OR gates and 2 NOT gates."
    ],
    "answer": "b",
    "explanation": "The correct answer is <strong>b) It requires 4 AND gates and 2 NOT gates.</strong> A 2-to-4 decoder has 2 input lines and 4 output lines. Let the inputs be A and B. The four outputs will be A'B', A'B, AB', and AB. This requires two NOT gates to generate A' and B', and four 2-input AND gates to generate the four output combinations.",
    "marks": 2
  },
  {
    "chapter": 3,
    "question": "Write a C function to swap two numbers using pointers.",
    "options": [
      "void swap(int a, int b) { int temp = a; a = b; b = temp; }",
      "void swap(int *a, int *b) { int temp = *a; *a = *b; *b = temp; }",
      "void swap(int &a, int &b) { int temp = a; a = b; b = temp; }",
      "int swap(int a, int b) { return b, a; }"
    ],
    "answer": "b",
    "explanation": "The correct answer is <strong>b) void swap(int *a, int *b) { int temp = *a; *a = *b; *b = temp; }</strong>. To swap the values of two variables in the calling function, you need to pass their addresses (pointers) to the swap function. The function then dereferences the pointers to access and modify the original values.",
    "marks": 2
  },
  {
    "chapter": 3,
    "question": "What is the difference between call by value and call by reference in C?",
    "options": [
      "There is no difference.",
      "In call by value, a copy of the argument is passed to the function. In call by reference, the address of the argument is passed.",
      "Call by value is used for integers, while call by reference is used for floats.",
      "Call by reference is faster than call by value."
    ],
    "answer": "b",
    "explanation": "The correct answer is <strong>b) In call by value, a copy of the argument is passed to the function. In call by reference, the address of the argument is passed.</strong> In call by value, any changes made to the argument inside the function do not affect the original value. In call by reference (achieved using pointers in C), changes made to the argument inside the function do affect the original value.",
    "marks": 2
  },
  {
    "chapter": 4,
    "question": "Explain the concept of memory hierarchy.",
    "options": [
      "A system of organizing memory in a computer system based on speed, cost, and capacity.",
      "A way to connect multiple memory modules.",
      "A method of memory allocation.",
      "A type of memory."
    ],
    "answer": "a",
    "explanation": "The correct answer is <strong>a) A system of organizing memory in a computer system based on speed, cost, and capacity.</strong> The memory hierarchy is a structure that uses a hierarchy of memory with different speeds. The levels in the hierarchy are, from top to bottom: registers, cache, main memory, and secondary storage. The higher levels are faster but have smaller capacity and are more expensive.",
    "marks": 2
  },
  {
    "chapter": 4,
    "question": "What is the difference between multitasking and multiprocessing?",
    "options": [
      "There is no difference.",
      "Multitasking is the execution of multiple tasks over a certain period of time by a single CPU, while multiprocessing is the execution of multiple tasks at the same time by multiple CPUs.",
      "Multitasking is used in embedded systems, while multiprocessing is used in general-purpose computers.",
      "Multiprocessing is a type of software, while multitasking is a type of hardware."
    ],
    "answer": "b",
    "explanation": "The correct answer is <strong>b) Multitasking is the execution of multiple tasks over a certain period of time by a single CPU, while multiprocessing is the execution of multiple tasks at the same time by multiple CPUs.</strong> Multitasking creates the illusion of parallel execution by rapidly switching between tasks. Multiprocessing achieves true parallel execution by using multiple processors.",
    "marks": 2
  },
  {
    "chapter": 5,
    "question": "Explain the process of subnetting.",
    "options": [
      "Combining multiple networks into one.",
      "Dividing a large network into smaller, more manageable networks.",
      "A method of routing.",
      "A way to assign IP addresses."
    ],
    "answer": "b",
    "explanation": "The correct answer is <strong>b) Dividing a large network into smaller, more manageable networks.</strong> Subnetting is the process of dividing a single, large IP network into smaller subnetworks (subnets). This is done by borrowing bits from the host portion of the IP address to create a subnet mask. Subnetting improves security, performance, and manageability.",
    "marks": 2
  },
  {
    "chapter": 5,
    "question": "What is the difference between symmetric and asymmetric encryption?",
    "options": [
      "There is no difference.",
      "Symmetric encryption uses the same key for encryption and decryption, while asymmetric encryption uses different keys.",
      "Symmetric encryption is more secure than asymmetric encryption.",
      "Asymmetric encryption is faster than symmetric encryption."
    ],
    "answer": "b",
    "explanation": "The correct answer is <strong>b) Symmetric encryption uses the same key for encryption and decryption, while asymmetric encryption uses different keys.</strong> In symmetric encryption, both the sender and receiver use the same secret key. In asymmetric encryption (also known as public-key cryptography), there is a pair of keys: a public key for encryption and a private key for decryption.",
    "marks": 2
  },
  {
    "chapter": 6,
    "question": "What is the Pumping Lemma for regular languages used for?",
    "options": [
      "To prove that a language is regular.",
      "To prove that a language is not regular.",
      "To convert a regular expression to a finite automaton.",
      "To minimize a finite automaton."
    ],
    "answer": "b",
    "explanation": "The correct answer is <strong>b) To prove that a language is not regular.</strong> The Pumping Lemma for regular languages is a theorem that states that all regular languages have a special property. If a language does not have this property, it cannot be regular. It is used to prove that a given language is not regular.",
    "marks": 2
  },
  {
    "chapter": 6,
    "question": "Explain the Cohen-Sutherland line clipping algorithm.",
    "options": [
      "It is an algorithm for clipping polygons.",
      "It is an algorithm for clipping lines against a rectangular window.",
      "It is an algorithm for 3D transformation.",
      "It is an algorithm for shading."
    ],
    "answer": "b",
    "explanation": "The correct answer is <strong>b) It is an algorithm for clipping lines against a rectangular window.</strong> The Cohen-Sutherland algorithm is a line clipping algorithm. It divides the 2D space into 9 regions and assigns a 4-bit code to each region. The algorithm uses these codes to quickly determine if a line is completely inside, completely outside, or partially inside the clipping window.",
    "marks": 2
  },
  {
    "chapter": 7,
    "question": "Explain the concept of virtual memory.",
    "options": [
      "A memory management technique that provides an idealized abstraction of the storage resources that are actually available on a given machine.",
      "A type of physical memory.",
      "A memory that is not real.",
      "A memory used by virtual machines."
    ],
    "answer": "a",
    "explanation": "The correct answer is <strong>a) A memory management technique that provides an idealized abstraction of the storage resources that are actually available on a given machine.</strong> Virtual memory allows a computer to compensate for shortages of physical memory by temporarily transferring pages of data from RAM to disk storage. This allows a program to use more memory than is physically available.",
    "marks": 2
  },
  {
    "chapter": 7,
    "question": "What is the difference between a process and a thread?",
    "options": [
      "There is no difference.",
      "A process is a program in execution, while a thread is a lightweight process that can run in parallel with other threads within the same process.",
      "A process is a hardware component, while a thread is a software component.",
      "A process is used for I/O operations, while a thread is used for CPU operations."
    ],
    "answer": "b",
    "explanation": "The correct answer is <strong>b) A process is a program in execution, while a thread is a lightweight process that can run in parallel with other threads within the same process.</strong> A process has its own memory space, while threads within the same process share the same memory space. This makes communication between threads faster than communication between processes.",
    "marks": 2
  },
  {
    "chapter": 8,
    "question": "Explain the concept of polymorphism in OOP.",
    "options": [
      "The ability of an object to take on many forms.",
      "The process of hiding the implementation details of an object.",
      "The process of creating a new class from an existing class.",
      "The process of combining data and methods into a single unit."
    ],
    "answer": "a",
    "explanation": "The correct answer is <strong>a) The ability of an object to take on many forms.</strong> Polymorphism allows objects of different classes to be treated as objects of a common superclass. It is often implemented using method overriding, where a subclass provides a specific implementation of a method that is already provided by its superclass.",
    "marks": 2
  },
  {
    "chapter": 8,
    "question": "What is the difference between a use case and a user story?",
    "options": [
      "There is no difference.",
      "A use case is a more formal and detailed description of a user's interaction with a system, while a user story is a short, simple description of a feature told from the perspective of the person who desires the new capability.",
      "A use case is used in agile development, while a user story is used in waterfall development.",
      "A use case is written by the developer, while a user story is written by the user."
    ],
    "answer": "b",
    "explanation": "The correct answer is <strong>b) A use case is a more formal and detailed description...</strong> Use cases are typically more detailed and structured, often including preconditions, postconditions, and alternative flows. User stories are more lightweight and are used to facilitate conversation and collaboration in agile teams.",
    "marks": 2
  },
  {
    "chapter": 9,
    "question": "Explain the concept of a genetic algorithm.",
    "options": [
      "A search heuristic that is inspired by Charles Darwin's theory of natural evolution.",
      "A sorting algorithm.",
      "A searching algorithm.",
      "A data structure."
    ],
    "answer": "a",
    "explanation": "The correct answer is <strong>a) A search heuristic that is inspired by Charles Darwin's theory of natural evolution.</strong> Genetic algorithms are a class of optimization algorithms. They use concepts like selection, crossover, and mutation to evolve a population of candidate solutions towards an optimal solution.",
    "marks": 2
  },
  {
    "chapter": 9,
    "question": "What is the difference between a greedy algorithm and a dynamic programming algorithm?",
    "options": [
      "A greedy algorithm makes the locally optimal choice at each step with the hope of finding a global optimum, while a dynamic programming algorithm breaks down a problem into smaller overlapping subproblems and solves each subproblem only once.",
      "A greedy algorithm is always optimal, while a dynamic programming algorithm is not.",
      "A dynamic programming algorithm is always faster than a greedy algorithm.",
      "There is no difference."
    ],
    "answer": "a",
    "explanation": "The correct answer is <strong>a) A greedy algorithm makes the locally optimal choice...</strong> Greedy algorithms do not always find the global optimum, but they are often faster and simpler to implement. Dynamic programming guarantees finding the optimal solution by solving all subproblems and storing their results.",
    "marks": 2
  },
  {
    "chapter": 10,
    "question": "Explain the difference between a project and a program.",
    "options": [
      "A project is a temporary endeavor undertaken to create a unique product, service, or result, while a program is a group of related projects managed in a coordinated way to obtain benefits and control not available from managing them individually.",
      "A project is a small program.",
      "A program is a small project.",
      "There is no difference."
    ],
    "answer": "a",
    "explanation": "The correct answer is <strong>a) A project is a temporary endeavor...</strong> A program is a larger undertaking that may consist of multiple projects. For example, building a new hospital could be a program, with the construction of the building, the installation of equipment, and the hiring of staff as individual projects.",
    "marks": 2
  },
  {
    "chapter": 10,
    "question": "What is the difference between PERT and CPM?",
    "options": [
      "PERT is a probabilistic model, while CPM is a deterministic model.",
      "PERT is used for small projects, while CPM is used for large projects.",
      "PERT is used for research and development projects, while CPM is used for construction projects.",
      "There is no difference."
    ],
    "answer": "a",
    "explanation": "The correct answer is <strong>a) PERT is a probabilistic model, while CPM is a deterministic model.</strong> PERT (Program Evaluation and Review Technique) uses three time estimates (optimistic, pessimistic, and most likely) to calculate the expected duration of a task. CPM (Critical Path Method) uses a single time estimate for each task. PERT is better suited for projects with uncertainty, while CPM is better for projects with predictable tasks.",
    "marks": 2
  }
]
      "It has a larger capacity than RAM",
      "It is non-volatile",
      "It reduces the average memory access time",
      "It is cheaper than main memory"
    ],
    "answer": "c",
    "explanation": "The correct answer is <strong>c) It reduces the average memory access time</strong>. Cache is a smaller, faster memory located closer to the CPU that stores copies of the data from the most frequently used main memory locations. This allows the CPU to access data faster than retrieving it from the main memory (RAM)."
  },
  {
    "chapter": 5,
    "question": "Which protocol operates at the Transport Layer of the OSI model?",
    "options": [
      "IP",
      "TCP",
      "HTTP",
      "Ethernet"
    ],
    "answer": "b",
    "explanation": "The correct answer is <strong>b) TCP</strong>. The Transport Layer (Layer 4) is responsible for end-to-end communication. TCP (Transmission Control Protocol) and UDP are the two primary protocols at this layer. IP operates at the Network Layer, HTTP at the Application Layer, and Ethernet at the Data Link Layer."
  },
  {
    "chapter": 6,
    "question": "What is a key characteristic of a regular language?",
    "options": [
      "It can be recognized by a Turing machine",
      "It can be recognized by a finite automaton",
      "It requires a stack for recognition",
      "It is context-sensitive"
    ],
    "answer": "b",
    "explanation": "The correct answer is <strong>b) It can be recognized by a finite automaton</strong>. Regular languages are a class of formal languages that can be recognized by a finite automaton (like a DFA or NFA). While a Turing machine can also recognize them, a finite automaton is the least powerful automaton that can do so. Languages requiring a stack are context-free languages."
  },
  {
    "chapter": 7,
    "question": "What is the time complexity of a binary search algorithm?",
    "options": [
      "O(n)",
      "O(log n)",
      "O(n^2)",
      "O(1)"
    ],
    "answer": "b",
    "explanation": "The correct answer is <strong>b) O(log n)</strong>. Binary search is an efficient algorithm for finding an item from a sorted list of items. It works by repeatedly dividing in half the portion of the list that could contain the item, until you've narrowed down the possible locations to just one. This logarithmic time complexity makes it very fast for large datasets."
  },
  {
    "chapter": 8,
    "question": "What is the primary goal of the Agile model of software development?",
    "options": [
      "To have comprehensive documentation",
      "To deliver working software frequently",
      "To have a fixed budget and timeline",
      "To avoid customer feedback until the end"
    ],
    "answer": "b",
    "explanation": "The correct answer is <strong>b) To deliver working software frequently</strong>. The core idea of Agile is to develop and release software in small, iterative cycles. This allows for flexibility, continuous feedback from the customer, and the ability to adapt to changing requirements, rather than focusing on heavy upfront documentation or rigid plans."
  },
  {
    "chapter": 9,
    "question": "In the context of AI, what is a 'heuristic'?",
    "options": [
      "A guaranteed optimal solution",
      "A rule of thumb or shortcut for problem-solving",
      "A type of neural network",
      "A formal logic system"
    ],
    "answer": "b",
    "explanation": "The correct answer is <strong>b) A rule of thumb or shortcut for problem-solving</strong>. Heuristics are practical, experience-based techniques that help in problem-solving, learning, and discovery. They are not guaranteed to be optimal or perfect but are used to speed up the process of finding a satisfactory solution, especially in complex problems where an exhaustive search is impractical."
  },
  {
    "chapter": 10,
    "question": "What does PERT stand for in project management?",
    "options": [
      "Project Evaluation and Resource Tracking",
      "Program Evaluation and Review Technique",
      "Project Execution and Reporting Tool",
      "Program Execution and Review Task"
    ],
    "answer": "b",
    "explanation": "The correct answer is <strong>b) Program Evaluation and Review Technique</strong>. PERT is a project management tool used to schedule, organize, and coordinate tasks within a project. It is particularly useful for analyzing the time required to complete each task and identifying the minimum time needed to complete the total project."
  }
]
